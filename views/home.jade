extends layout

block content
		div(style="text-align: center;position: relative;")
             a(href="/search", class="sunlogos")
                img(src="/images/yoke4.png", alt="The Yoke",  title="Yoke", class="yokelogo")
    - if(latestshares != null && latestshares != undefined)
        style.
            canvas{
                width: 350px !important;
                height: 85% !important;
                position: relative;
                margin-top: -450px;
            }

        script(src="/javascripts/threejs/build/more/three.min.js")

        script(src="/javascripts/threejs/examples/js/effects/AnaglyphEffect.js")

        script(src="/javascripts/threejs/examples/js/Detector.js")

        script(src="/javascripts/threejs/threex.dynamictexture.js")


        script.
            var obj = JSON.parse('#{JSON.stringify(latestshares)}'.replace(/&quot;/g, '"'));
            console.log(obj);
            for(var prop in obj)
                console.log(obj[prop].agent);
            var wordwrap = function(long_string, max_char){

            var sum_length_of_words = function(word_array){
            var out = 0;
            if (word_array.length!=0){
            for (var i=0; i<word_array.length; i++){
            var word = word_array[i];
            out = out + word.length;
            }
            };
            return out;
            }

            var split_out = [[]];
            var split_string = long_string.split(' ');
            for (var i=0; i<split_string.length; i++){
            var word = split_string[i];

            if ((sum_length_of_words(split_out[split_out.length-1]) + word.length) > max_char){
            split_out = split_out.concat([[]]);
            }

            split_out[split_out.length-1] = split_out[split_out.length-1].concat(word);
            }

            for (var i=0; i<split_out.length; i++){
            split_out[i] = split_out[i].join(" ");
            }

            return split_out.join('\n');
            };

            var objects = [];
            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2();
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );

            var scene = new THREE.Scene();
            scene.background = new THREE.Color( "white" );
            var camera = new THREE.PerspectiveCamera(400, 300/(window.innerHeight * 0.95), 1, 10000);

            var renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setSize(220, window.innerHeight * 0.9);
            renderer.setClearColor( 0xffffff );
            document.body.appendChild(renderer.domElement);

            var colors = [0x8a6d3b,0x3d9dcb,0x337ab7];

            var geometry = new THREE.BoxGeometry(100, 100, 100, 10, 10, 10) /*new THREE.SphereBufferGeometry( 300, 32, 32)*/;
            var geometry1 = /*new THREE.BoxGeometry(50, 50, 50, 10, 10, 10)*/ new THREE.SphereBufferGeometry( 50, 32, 32);
            var geometry2 = new THREE.BoxGeometry(300, 100, 100, 10, 10, 10)

            var dynamicTexture  = new THREEx.DynamicTexture(64,64);
            dynamicTexture.context.font = "normal 3px Verdana"
            dynamicTexture.drawText('Last Transactions', 16, 32, 'white');

            var material = new THREE.MeshBasicMaterial({color: 0x8a6d3b, wireframe: true /*, map: dynamicTexture.texture*/ }); // yoke color
            var material1 = new THREE.MeshBasicMaterial({color: 0x3d9dcb, wireframe: true }); // lab color
            var material2 = new THREE.MeshBasicMaterial({color: 0x337ab7, wireframe: true }); // logo color
            var cube = new THREE.Mesh(geometry, material);
            var cube1 = new THREE.Mesh(geometry1, material1);
            var cube2 = new THREE.Mesh(geometry1, material);
            var cube3 = new THREE.Mesh(geometry2, material);
            var cube4 = new THREE.Mesh(geometry1, material2);
            scene.add(cube4);
            scene.add(cube1);
            scene.add(cube2);

            objects.push( cube4 );
            objects.push( cube1 );
            objects.push( cube2 );

            var mesh1, mesh2, mesh3;

            var loader = new THREE.FontLoader();

            loader.load( '/javascripts/threejs/fonts/helvetiker_regular.typeface.json', function ( font ) {

            var t = "Exosome";

            //for(var prop in obj)
            //    console.log(obj[prop].agent);

            var test_string = "this is a long string that should be word wrapped, hopefully";
            console.log(wordwrap(test_string, 5));

            var textGeo = new THREE.TextGeometry( wordwrap(obj[0].agent, 20), {font: font, size: 10,height: 3} );

            var textGeo2 = new THREE.TextGeometry( wordwrap(obj[1].agent, 20), {font: font, size: 10,height: 3} );

            var textGeo3 = new THREE.TextGeometry( wordwrap(obj[2].agent, 20), {font: font, size: 10,height: 3} );

            var textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000 } );

            mesh1 = new THREE.Mesh( textGeo, textMaterial );
            mesh2 = new THREE.Mesh( textGeo2, textMaterial );
            mesh3 = new THREE.Mesh( textGeo3, textMaterial );

            scene.add( mesh1 );
            scene.add( mesh2 );
            scene.add( mesh3 );

            } );

            camera.position.z = 1000;
            camera.position.y = window.innerHeight * 0.3;
            console.log("height camera: " + window.innerHeight * 0.3);

            function onDocumentMouseDown( event ) {

                event.preventDefault();

                mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

                raycaster.setFromCamera( mouse, camera );

                var intersects = raycaster.intersectObjects( objects );

                if ( intersects.length > 0 ) {
                    var col = intersects[ 0 ].object.material.color.getHex();
                    console.log(col);
                    var rand = Math.floor((Math.random() * 3));
                    console.log("rand: "+rand);
                    intersects[ 0 ].object.material.color.setHex( colors[rand]);

                    /*var particle = new THREE.Sprite( particleMaterial );
                    particle.position.copy( intersects[ 0 ].point );
                    particle.scale.x = particle.scale.y = 16;
                    scene.add( particle );
                    */

                }

                /*
                // Parse all the faces
                for ( var i in intersects ) {

                    intersects[ i ].face.material[ 0 ].color.setHex( Math.random() * 0xffffff | 0x80000000 );

                }
                */
            }


            function render() {
            requestAnimationFrame(render);

            var timer = 0.00007 * Date.now();
            //cube.position.x = 5 * Math.cos( timer );
            //cube.position.y = 5 * Math.sin( timer * 1.1 );

            //cube1.position.x = 50 * Math.cos( timer);
            cube1.position.y = (window.innerHeight / 2) * Math.cos( timer * 2.1);

            cube2.position.y = 0.8 * (window.innerHeight / 2) * Math.cos(timer * 3.1);
            cube2.position.x = 105;

            cube4.position.y = (window.innerHeight / 2) * Math.cos( timer * 3.1 );
            cube4.position.x = -105;

            mesh2.position.set( cube2.position.x - 25, cube2.position.y + 60, 0);
            mesh3.position.set( cube4.position.x - 25, cube4.position.y + 60, 0);
            mesh1.position.set( -25, cube1.position.y + 60, 0);

            //console.log("cube1.position.y: " + cube1.position.y);

            //console.log("cube2.position.y: " + cube2.position.y);

            //cube1.position.z = 50 * Math.cos( timer);

            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
            cube.rotation.z += 0.01;

            cube3.rotation.y = 10;
            //cube3.rotation.y = 20;
            //cube3.rotation.z = 0.01;

            cube1.rotation.x += 0.02;
            cube1.rotation.y += 0.02;

            cube4.rotation.x += 0.02;
            cube4.rotation.y += 0.02;

            cube2.rotation.x += 0.02;
            cube2.rotation.y += 0.02;
            cube2.rotation.y += 0.02;





            renderer.render(scene, camera);
            };

            render();