extends layout

block content
    - if(latestshares != null && latestshares != undefined)
        div(id="canvasing")
            style.
                canvas{
                    //width: 100% !important;
                    //height: 90% !important;
                    background-color: 'white' !important;
                    position: relative;
                    z-index: -2;
                    //position: relative;
                    //margin-top: -450px;
                }

            script(src="/javascripts/threejs/build/more/three.min.js")

            script(src="/javascripts/threejs/examples/js/effects/AnaglyphEffect.js")

            script(src="/javascripts/threejs/examples/js/Detector.js")

            script(src="/javascripts/threejs/threex.dynamictexture.js")


            script.
                var obj = JSON.parse('#{JSON.stringify(latestshares)}'.replace(/&quot;/g, '"'));
                var savefont;
                console.log(obj);
                for(var prop in obj)
                    console.log(obj[prop].agent);
                var wordwrap = function(long_string, max_char){

                var sum_length_of_words = function(word_array){
                var out = 0;
                if (word_array.length!=0){
                for (var i=0; i<word_array.length; i++){
                var word = word_array[i];
                out = out + word.length;
                }
                };
                return out;
                }

                var split_out = [[]];
                var split_string = long_string.split(' ');
                for (var i=0; i<split_string.length; i++){
                var word = split_string[i];

                if ((sum_length_of_words(split_out[split_out.length-1]) + word.length) > max_char){
                split_out = split_out.concat([[]]);
                }

                split_out[split_out.length-1] = split_out[split_out.length-1].concat(word);
                }

                for (var i=0; i<split_out.length; i++){
                split_out[i] = split_out[i].join(" ");
                }

                return split_out.join('\n ');
                };

                var objects = [];
                var meshes = [];
                var raycaster = new THREE.Raycaster();
                var mouse = new THREE.Vector2();
                //document.addEventListener( 'touchstart', onDocumentMouseDown, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );

                

                var scene = new THREE.Scene();
                scene.background = new THREE.Color( "white" );
                //var camera = new THREE.PerspectiveCamera(400, window.innerWidth /(window.innerHeight), 1, 10000);
                var camera = new THREE.PerspectiveCamera(400, window.innerWidth /(window.innerHeight), 1, 10000);

                console.log("camera: " + window.innerWidth);

                var renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor( 0xffffff );
                document.body.appendChild(renderer.domElement);

                var colors = [0x8a6d3b,0x3d9dcb,0x337ab7];

                var geometry = new THREE.BoxGeometry(50, 50, 50, 10, 10, 10);
                var geometry3 = new THREE.BoxGeometry(window.innerHeight/2.5, 2, 2, 2, 2, 2);
                var geometry1 = new THREE.SphereBufferGeometry( 48, 16, 16);
                var geometry2 = new THREE.BoxGeometry(300, 100, 100, 10, 10, 10)

                var material = new THREE.MeshBasicMaterial({color: 0x8a6d3b, wireframe: true }); // yoke color
                var material1 = new THREE.MeshBasicMaterial({color: 0x3d9dcb, wireframe: true }); // lab color
                var material2 = new THREE.MeshBasicMaterial({color: 0x337ab7, wireframe: true }); // logo color

                var materials = [material, material1, material2];

                var textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000 } );

                var i = 0;
                for(var prop in obj){
                    var cube = new THREE.Mesh(geometry1, materials[i]);
                    i++;
                    if(i > 2){
                        i = 0;
                    }
                    scene.add(cube);
                    objects.push( cube );
                }

                var material4 = new THREE.LineBasicMaterial({
                    color: 0x8a6d3b
                });

                var geometry4 = new THREE.Geometry();
                geometry4.vertices.push(
                    new THREE.Vector3( 0, 0, 0 ),
                    new THREE.Vector3( window.innerHeight/5, 0, 0 )//,
                    //new THREE.Vector3( 400, 0, 0 )
                );
                var bar = new THREE.Line( geometry4, material4 );
                var geometry5 = new THREE.SphereBufferGeometry( 5, 16, 16);
                var circle = new THREE.Mesh(geometry5, material1);
                //scene.add(bar);

                var cube1 = new THREE.Mesh(geometry1, material1);
                var cube2 = new THREE.Mesh(geometry1, material);
                var cube3 = new THREE.Mesh(geometry2, material);
                var cube4 = new THREE.Mesh(geometry1, material2);
                //scene.add(cube4);
                //scene.add(cube1);
                //scene.add(cube2);

                //objects.push( cube4 );
                //objects.push( cube1 );
                //objects.push( cube2 );

                var mesh1, mesh2, mesh3;

                for(var prop in obj){
                    var mesh;
                    meshes.push(mesh);
                }
                console.log("pushing mesh: " + meshes);

                var loader = new THREE.FontLoader();

                loader.load( '/javascripts/threejs/fonts/helvetiker_regular.typeface.json', function ( font ) {

                savefont = font;

                var t = "Exosome";

                //for(var prop in obj)
                //    console.log(obj[prop].agent);

                var test_string = "this is a long string that should be word wrapped, hopefully";
                console.log(wordwrap(test_string, 5));

                var textGeo = new THREE.TextGeometry( wordwrap(obj[0].agent, 20), {font: font, size: 10,height: 3} );

                var textGeo2 = new THREE.TextGeometry( wordwrap(obj[1].agent, 20), {font: font, size: 10,height: 3} );

                var textGeo3 = new THREE.TextGeometry( wordwrap(obj[2].agent, 20), {font: font, size: 10,height: 3} );

                

                mesh1 = new THREE.Mesh( textGeo, textMaterial );
                mesh2 = new THREE.Mesh( textGeo2, textMaterial );
                mesh3 = new THREE.Mesh( textGeo3, textMaterial );

                //scene.add( mesh1 );
                //scene.add( mesh2 );
                //scene.add( mesh3 );

                //var timer0 = 0.00007 * Date.now();
                var timer0 = 0.00007 * 123456789;
                var x = 0;
                var x1 = 0;
                //var y = (window.innerHeight / 2) * Math.cos( timer0 * 3.1);
                var y = 200 + (window.innerHeight) * Math.cos( timer0 * 3.1);
                var y1 = 0;
                var diff = [1, -1];
                var j = 0;
                var offset = window.innerWidth/10;

                for(var prop in meshes){
                    console.log("y: " + y);
                    console.log("x: " + x);
                    console.log("prop: " + prop);
                    console.log("obj[prop].agent: " + obj[prop].agent);
                    var text = new THREE.TextGeometry( wordwrap(obj[prop].agent, 10), {font: font, size: 8,height: 2} );
                    meshes[prop] = new THREE.Mesh( text, textMaterial );


                //console.log("meshes: " + meshes);
               
                    objects[prop].position.y = y;
                    objects[prop].position.x = x;
                    //meshes[prop].position.set = (x - 25, y + 60, 0);
                    meshes[prop].position.x = x - 20;
                    meshes[prop].position.y = y - 65;
                    meshes[prop].position.z = 0;
                    //x = diff[j] * ((prop/objects.length + 1) * window.innerWidth/(2*objects.length) + 300);
                    if(prop < (objects.length/2 - 1)){
                        console.log("y_0: " + y);
                        console.log("positive " + offset);
                        x += offset;
                        y += offset;
                        console.log("y_1: " + y);
                    } else {
                        console.log("negative");
                        x1 = x1 - offset;
                        x = x1;
                        y1 = y1 - offset;
                        y = y1;
                    }
                    
                    //y = y + 0.8 * y;

                    y = 200 + (prop/objects.length + 2) * ((window.innerHeight/(2*objects.length))) * diff[j];
                    // y = (window.innerHeight / 2) * Math.cos( timer0  * diff[j]) + y;
                    

                    j++;
                    if(j>1){
                        j = 0;
                    }
                


                    scene.add( meshes[prop] );
                    //meshes.push(mesh);
                    
                }
                console.debug(meshes);

                } );



                camera.position.z = 1000;
                camera.position.y = window.innerHeight * 0.15;
                console.log("height camera: " + window.innerHeight * 0.1);

                var countts = 0;
                var count = 0;

                function onDocumentMouseDown( event ) {
                    //console.debug(event);
                    //event.preventDefault();
                    

                    mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
                    mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

                    raycaster.setFromCamera( mouse, camera );

                    var intersects = raycaster.intersectObjects( objects );
                    

                    var particleMaterial = new THREE.PointsMaterial({
                      color: 0x000000
                    });
                    if ( intersects.length > 0 ) {
                        var col = intersects[ 0 ].object.material.color.getHex();
                        var int = intersects[ 0 ];
                        //console.debug(intersects[ 0 ].object);
                        //console.log(intersects[ 0 ].object.name);
                        //console.debug(savefont);
                        var rand = Math.floor((Math.random() * 3));
                        var coloring = colors[rand];
                        intersects[ 0 ].object.material.color.setHex( colors[rand] );
                        intersects[ 0 ].object.geometry = geometry;

                        if(count == objects.length - 1 && bar){
                            scene.add(bar);
                            scene.add(circle);
                        }
                        
                        if(count < objects.length){
                        
                        //console.log("name: " + intersects[ 0 ].object.name);
                        //console.log("savefont: " + savefont);
                        var text = new THREE.TextGeometry( wordwrap(intersects[ 0 ].object.name, 10), {font:savefont, weight: "bold", size:10, height:3} );
                        var textMaterial1 = new THREE.MeshBasicMaterial( { color: colors[rand] } );
                        var t = new THREE.Mesh( text, textMaterial1 );
                        //console.log("coloring: " + colors[rand]);
                        
                        countts +=6.2832/objects.length;
                        t.position.x = 200*Math.sin(countts) - 35; //- window.innerWidth/18; //200*Math.cos(countts) + 0; // -35
                        t.position.y = 200*Math.cos(countts) + window.innerHeight/4.66; // +150

                        //t.position.x = (window.innerWidth / 1.5) + countts * 25;
                        //t.position.y = (window.innerHeight / 1.5) + countts * 25;
                        
                        
                        scene.add( t );
                        //console.log("tpositiony: " + t.position.y);
                        //console.log("tpositionx: " + t.position.x);
                        //console.log("count: " + count);
                        //console.log("height: " + window.innerHeight);
                        //console.log("width: " + window.innerWidth);
                        count++;
                        }

                       /* var particle = new THREE.Sprite( particleMaterial );
                        particle.position.copy( intersects[ 0 ].point );
                        particle.scale.x = particle.scale.y = 100;
                        scene.add( t );
                        */

                    }

                    /*
                    // Parse all the faces
                    for ( var i in intersects ) {

                        intersects[ i ].face.material[ 0 ].color.setHex( Math.random() * 0xffffff | 0x80000000 );

                    }
                    */
                }


                function render() {
                requestAnimationFrame(render);

                var timer = 0.00007 * Date.now();

                var timer0 = 0.00007 * Date.now();
                var x = 0;
                var y = (window.innerHeight / 2) * Math.cos( timer0 * 3.1);
                var diff = [1, -1];
                var j = 0;
                var x1 = 0;
                //console.log("cubey: " + y);
                for(var prop in objects){
                    var cube = objects[prop];
                    cube.name = obj[prop].lab;
                    cube.rotation.x += 0.02;
                    cube.rotation.y += 0.02;
                    cube.position.y = y;
                    cube.addEventListener( 'touchend', onDocumentMouseDown, false );
                    //cube.position.x = x;
                    var m = meshes[prop];
                    //console.debug("agent is: " + obj[prop].agent);

                    //
                    //m.position.set = (x - 25, y + 60, 0);
                    //meshes[prop].position.x = x - 30;
                    if ( meshes[prop] ) {
                    meshes[prop].position.y = y - 65;
                    //meshes[prop].position.x = x - 30;
                    }
                    //meshes[prop].position.z = 0;
                    if(prop == 0){
                        prop = 1.5;
                    }
                    //x = x + (window.innerWidth/objects.length * prop * diff[j]);
                    //y = y + 0.8 * y;

                    y = (window.innerHeight / 2) * Math.cos( timer0 * prop * diff[j]);

                    j++;
                    if(j>1){
                        j = 0;
                    }

                    /*if(prop < (objects.length/2 - 1)){
                        console.log("y_0: " + x);
                        x += 100;
                    } else {
                        console.log("negative");
                        x1 = x1 - 100;
                        x = x1;
                    }*/
                }
                if(bar){
                    var lineAngle = (60 * Math.PI * timer) / 180;
                    bar.rotation.z = lineAngle;
                    bar.position.y = window.innerHeight / 5;
                }
                if(circle){
                    circle.position.y = window.innerHeight / 5;
                }

                //cube.position.x = 5 * Math.cos( timer );
                //cube.position.y = 5 * Math.sin( timer * 1.1 );

                //cube1.position.x = 50 * Math.cos( timer);
                cube1.position.y = (window.innerHeight / 2) * Math.cos( timer * 2.1);
                cube1.position.x = 305;

                cube2.position.y = 0.8 * (window.innerHeight / 2) * Math.cos(timer * 3.1);
                cube2.position.x = 405;

                cube4.position.y = (window.innerHeight / 2) * Math.cos( timer * 3.1 );
                cube4.position.x = -305;

                if ( mesh2 ) {
                mesh2.position.set( cube2.position.x - 25, cube2.position.y + 60, 0);
                }
                if ( mesh3 ) {
                mesh3.position.set( cube4.position.x - 25, cube4.position.y + 60, 0);
                } if ( mesh1 ) { mesh1.position.set( cube1.position.x - 25, cube1.position.y + 60, 0);
                }

                //console.log("cube1.position.y: " + cube1.position.y);

                //console.log("cube2.position.y: " + cube2.position.y);

                //cube1.position.z = 50 * Math.cos( timer);

                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
                cube.rotation.z += 0.01;

                cube3.rotation.y = 10;
                //cube3.rotation.y = 20;
                //cube3.rotation.z = 0.01;

                cube1.rotation.x += 0.02;
                cube1.rotation.y += 0.02;

                cube4.rotation.x += 0.02;
                cube4.rotation.y += 0.02;

                cube2.rotation.x += 0.02;
                cube2.rotation.y += 0.02;
                cube2.rotation.y += 0.02;

                renderer.render(scene, camera);
                };

                render();

    div(style="text-align: center;position: relative;z-index: 1;")
        a(href="/search", class="sunlogos")
            img(src="/images/logo_clear.png", alt="The Yoke",  title="Yoke", class="yokelogo", id="yokelogo", style="z-index: 1;position: relative; /*margin-top: -925px;*/")
    script.
        $('.yokelogo').css( "margin-top", (-1.2 * window.innerHeight) );
        //$('body').css( "background-color", "#8a6d3b" );
        //$('canvas').css( "opacity", "0.6" );
        console.log("top: " + window.innerHeight);
        console.log($("#yokelogo").css("margin-top"));
