extends layout

block content
    - if(latestshares != null && latestshares != undefined)
        div(id="canvasing")
            style.
                canvas{
                    //width: 100% !important;
                    //height: 90% !important;
                    background-color: 'white' !important;
                    //position: relative;
                    //margin-top: -450px;
                }

            script(src="/javascripts/threejs/build/more/three.min.js")

            script(src="/javascripts/threejs/examples/js/effects/AnaglyphEffect.js")

            script(src="/javascripts/threejs/examples/js/Detector.js")

            script(src="/javascripts/threejs/threex.dynamictexture.js")


            script.
                var obj = JSON.parse('#{JSON.stringify(latestshares)}'.replace(/&quot;/g, '"'));
                console.log(obj);
                for(var prop in obj)
                    console.log(obj[prop].agent);
                var wordwrap = function(long_string, max_char){

                var sum_length_of_words = function(word_array){
                var out = 0;
                if (word_array.length!=0){
                for (var i=0; i<word_array.length; i++){
                var word = word_array[i];
                out = out + word.length;
                }
                };
                return out;
                }

                var split_out = [[]];
                var split_string = long_string.split(' ');
                for (var i=0; i<split_string.length; i++){
                var word = split_string[i];

                if ((sum_length_of_words(split_out[split_out.length-1]) + word.length) > max_char){
                split_out = split_out.concat([[]]);
                }

                split_out[split_out.length-1] = split_out[split_out.length-1].concat(word);
                }

                for (var i=0; i<split_out.length; i++){
                split_out[i] = split_out[i].join(" ");
                }

                return split_out.join('\n');
                };

                var objects = [];
                var meshes = [];
                var raycaster = new THREE.Raycaster();
                var mouse = new THREE.Vector2();
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );

                var scene = new THREE.Scene();
                scene.background = new THREE.Color( "white" );
                var camera = new THREE.PerspectiveCamera(400, window.innerWidth /(window.innerHeight), 1, 10000);

                var renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor( 0xffffff );
                document.body.appendChild(renderer.domElement);

                var colors = [0x8a6d3b,0x3d9dcb,0x337ab7];

                var geometry = new THREE.BoxGeometry(100, 100, 100, 10, 10, 10);
                var geometry1 = new THREE.SphereBufferGeometry( 50, 16, 16);
                var geometry2 = new THREE.BoxGeometry(300, 100, 100, 10, 10, 10)

                var material = new THREE.MeshBasicMaterial({color: 0x8a6d3b, wireframe: true }); // yoke color
                var material1 = new THREE.MeshBasicMaterial({color: 0x3d9dcb, wireframe: true }); // lab color
                var material2 = new THREE.MeshBasicMaterial({color: 0x337ab7, wireframe: true }); // logo color

                var materials = [material, material1, material2];

                var textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000 } );

                var i = 0;
                for(var prop in obj){
                    var cube = new THREE.Mesh(geometry1, materials[i]);
                    i++;
                    if(i > 2){
                        i = 0;
                    }
                    scene.add(cube);
                    objects.push( cube );
                }

                
                var cube1 = new THREE.Mesh(geometry1, material1);
                var cube2 = new THREE.Mesh(geometry1, material);
                var cube3 = new THREE.Mesh(geometry2, material);
                var cube4 = new THREE.Mesh(geometry1, material2);
                scene.add(cube4);
                scene.add(cube1);
                scene.add(cube2);

                objects.push( cube4 );
                objects.push( cube1 );
                objects.push( cube2 );

                var mesh1, mesh2, mesh3;

                for(var prop in obj){
                    var mesh;
                    meshes.push(mesh);
                }
                console.log("pushing mesh: " + meshes);

                var loader = new THREE.FontLoader();

                loader.load( '/javascripts/threejs/fonts/helvetiker_regular.typeface.json', function ( font ) {

                var t = "Exosome";

                //for(var prop in obj)
                //    console.log(obj[prop].agent);

                var test_string = "this is a long string that should be word wrapped, hopefully";
                console.log(wordwrap(test_string, 5));

                var textGeo = new THREE.TextGeometry( wordwrap(obj[0].agent, 20), {font: font, size: 10,height: 3} );

                var textGeo2 = new THREE.TextGeometry( wordwrap(obj[1].agent, 20), {font: font, size: 10,height: 3} );

                var textGeo3 = new THREE.TextGeometry( wordwrap(obj[2].agent, 20), {font: font, size: 10,height: 3} );

                

                mesh1 = new THREE.Mesh( textGeo, textMaterial );
                mesh2 = new THREE.Mesh( textGeo2, textMaterial );
                mesh3 = new THREE.Mesh( textGeo3, textMaterial );

                scene.add( mesh1 );
                scene.add( mesh2 );
                scene.add( mesh3 );

                //var timer0 = 0.00007 * Date.now();
                var timer0 = 0.00007 * 123456789;
                var x = 0;
                var x1 = 0;
                //var y = (window.innerHeight / 2) * Math.cos( timer0 * 3.1);
                var y = (window.innerHeight/2) * Math.cos( timer0 * 3.1);
                var y1 = 0;
                var diff = [1, -1];
                var j = 0;

                for(var prop in meshes){
                    console.log("y: " + y);
                    console.log("x: " + x);
                    var text = new THREE.TextGeometry( wordwrap(obj[prop].agent, 20), {font: font, size: 10,height: 3} );
                    meshes[prop] = new THREE.Mesh( text, textMaterial );


                //console.log("meshes: " + meshes);
               
                    objects[prop].position.y = y;
                    objects[prop].position.x = x;
                    //meshes[prop].position.set = (x - 25, y + 60, 0);
                    meshes[prop].position.x = x - 25;
                    meshes[prop].position.y = y + 60;
                    meshes[prop].position.z = 0;
                    //x = diff[j] * ((prop/objects.length + 1) * window.innerWidth/(2*objects.length) + 300);
                    if(prop < (objects.length/2 - 2)){
                        console.log("positive " + window.innerWidth/objects.length);
                        x += 200;
                        y += 200;
                    } else {
                        console.log("negative");
                        x1 = x1 - 200;
                        x = x1;
                        y1 = y1 - 200;
                        y = y1;
                    }
                    
                    //y = y + 0.8 * y;

                    y = (prop/objects.length + 1) * ((window.innerHeight/(2*objects.length))) * diff[j];
                    // y = (window.innerHeight / 2) * Math.cos( timer0  * diff[j]) + y;
                    

                    j++;
                    if(j>1){
                        j = 0;
                    }
                


                    scene.add( meshes[prop] );
                    //meshes.push(mesh);
                    
                }
                console.debug(meshes);

                } );



                camera.position.z = 1000;
                camera.position.y = window.innerHeight * 0.3;
                console.log("height camera: " + window.innerHeight * 0.3);

                function onDocumentMouseDown( event ) {

                    event.preventDefault();

                    mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
                    mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

                    raycaster.setFromCamera( mouse, camera );

                    var intersects = raycaster.intersectObjects( objects );

                    if ( intersects.length > 0 ) {
                        var col = intersects[ 0 ].object.material.color.getHex();
                        console.log(col);
                        var rand = Math.floor((Math.random() * 3));
                        console.log("rand: "+rand);
                        intersects[ 0 ].object.material.color.setHex( colors[rand]);

                        /*var particle = new THREE.Sprite( particleMaterial );
                        particle.position.copy( intersects[ 0 ].point );
                        particle.scale.x = particle.scale.y = 16;
                        scene.add( particle );
                        */

                    }

                    /*
                    // Parse all the faces
                    for ( var i in intersects ) {

                        intersects[ i ].face.material[ 0 ].color.setHex( Math.random() * 0xffffff | 0x80000000 );

                    }
                    */
                }


                function render() {
                requestAnimationFrame(render);

                var timer = 0.00007 * Date.now();

                var timer0 = 0.00007 * Date.now();
                var x = 0;
                var y = (window.innerHeight / 2) * Math.cos( timer0 * 3.1);
                var diff = [1, -1];
                var j = 0;
                //console.log("meshes: " + meshes);
                for(var prop in objects){
                    var cube = objects[prop];
                    cube.rotation.x += 0.02;
                    cube.rotation.y += 0.02;
                    //cube.position.y = y;
                    //cube.position.x = x;
                    var m = meshes[prop];
                    //console.debug(m);
                    //m.position.set = (x - 25, y + 60, 0);
                    //meshes[prop].position.x = x - 25;
                    //meshes[prop].position.y = y + 60;
                    //meshes[prop].position.z = 0;
                    x = x + (window.innerWidth/objects.length * prop * diff[j]);
                    //y = y + 0.8 * y;

                    y = (window.innerHeight / 2) * Math.cos( timer0 * prop * diff[j]);

                    j++;
                    if(j>1){
                        j = 0;
                    }
                }

                //cube.position.x = 5 * Math.cos( timer );
                //cube.position.y = 5 * Math.sin( timer * 1.1 );

                //cube1.position.x = 50 * Math.cos( timer);
                cube1.position.y = (window.innerHeight / 2) * Math.cos( timer * 2.1);
                cube1.position.x = 305;

                cube2.position.y = 0.8 * (window.innerHeight / 2) * Math.cos(timer * 3.1);
                cube2.position.x = 405;

                cube4.position.y = (window.innerHeight / 2) * Math.cos( timer * 3.1 );
                cube4.position.x = -305;

                mesh2.position.set( cube2.position.x - 25, cube2.position.y + 60, 0);
                mesh3.position.set( cube4.position.x - 25, cube4.position.y + 60, 0);
                mesh1.position.set( cube1.position.x - 25, cube1.position.y + 60, 0);

                //console.log("cube1.position.y: " + cube1.position.y);

                //console.log("cube2.position.y: " + cube2.position.y);

                //cube1.position.z = 50 * Math.cos( timer);

                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
                cube.rotation.z += 0.01;

                cube3.rotation.y = 10;
                //cube3.rotation.y = 20;
                //cube3.rotation.z = 0.01;

                cube1.rotation.x += 0.02;
                cube1.rotation.y += 0.02;

                cube4.rotation.x += 0.02;
                cube4.rotation.y += 0.02;

                cube2.rotation.x += 0.02;
                cube2.rotation.y += 0.02;
                cube2.rotation.y += 0.02;

                renderer.render(scene, camera);
                };

                render();

    div(style="text-align: center;position: relative;")
        a(href="/search", class="sunlogos")
            img(src="/images/logo_clear.png", alt="The Yoke",  title="Yoke", class="yokelogo", style="z-index: 2;position: relative;margin-top: -770px;")
